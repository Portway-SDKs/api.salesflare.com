/*
Salesflare API

# Introduction  ## Getting Started  The Salesflare API allows you to access and build your own applications or integrations that interact with Salesflare.  The Salesflare API provides a RESTful interface with JSON-formatted responses to access most Salesflare resources.  ## Authentication  The Salesflare API uses bearer token based authentication, which means you need to use the key-value pair \"Authorization : Bearer APIKEY\" in the header to authenticate.  You can make an API key in [\"Settings\" > \"API keys\"](https://app.salesflare.com/#/settings/apikeys).  Click on the large orange \"+\" button on the bottom right of the screen to create an API key.  ![Screenshot API Key Settings](https://lib.salesflare.com/api_docs/screenshot_settings_apikeys.png)  ## Requests  All requests must be sent using HTTPS with TLS 1.2 or higher. Please make sure your developer tools support this version of TLS as older versions or SSL are not supported for security reasons.  For PUT or POST requests (e.g. create, update), the payload must be provided as JSON in the request body.  ## Responses  Responses use HTTP status codes, with the most typical ones being:  | Code                   | Meaning               | |------------------------|-----------------------| | Successful Responses                           | | 200                    | OK                    | | Error Responses                                | | 400                    | Bad Request           | | 401                    | Unauthorized          | | 404                    | Not Found             | | 429                    | Too Many Requests     | | 500                    | Internal Server Error |  ## Testing  We recommend testing our API with Postman.  ### Download specification  Our API is documented following the OpenAPI specification. You can download it [here](https://api.salesflare.com/openapi.json)  ### Import in Postman  To import the collection, open Postman and click Import, then select \"Import From Link\"  Copy & Paste the following link and press the \"Import\" button:  > https://api.salesflare.com/openapi.json  ![Screenshot Postman Import](https://lib.salesflare.com/api_docs/screenshot_postman_import.png)  ## Support  For API questions and support, please email support@salesflare.com or click the chat bubble below.

API version: 1.0.0
Contact: support@salesflare.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package salesflare

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"time"
)


// ContactsAPIService ContactsAPI service
type ContactsAPIService service

type ApiGetContactsRequest struct {
	ctx context.Context
	ApiService *ContactsAPIService
	id *[]float32
	name *string
	email *string
	phoneNumber *string
	domain *string
	modificationAfter *time.Time
	modificationBefore *time.Time
	creationAfter *time.Time
	creationBefore *time.Time
	account *[]float32
	tag *[]float32
	tagName *[]string
	positionRole *[]string
	addressCountry *[]string
	addressStateRegion *[]string
	addressCity *[]string
	includeArchived *bool
	search *string
	type_ *string
	limit *float32
	offset *float32
	custom *string
	orderBy *[]string
	q *string
}

func (r ApiGetContactsRequest) Id(id []float32) ApiGetContactsRequest {
	r.id = &id
	return r
}

func (r ApiGetContactsRequest) Name(name string) ApiGetContactsRequest {
	r.name = &name
	return r
}

func (r ApiGetContactsRequest) Email(email string) ApiGetContactsRequest {
	r.email = &email
	return r
}

func (r ApiGetContactsRequest) PhoneNumber(phoneNumber string) ApiGetContactsRequest {
	r.phoneNumber = &phoneNumber
	return r
}

func (r ApiGetContactsRequest) Domain(domain string) ApiGetContactsRequest {
	r.domain = &domain
	return r
}

func (r ApiGetContactsRequest) ModificationAfter(modificationAfter time.Time) ApiGetContactsRequest {
	r.modificationAfter = &modificationAfter
	return r
}

func (r ApiGetContactsRequest) ModificationBefore(modificationBefore time.Time) ApiGetContactsRequest {
	r.modificationBefore = &modificationBefore
	return r
}

func (r ApiGetContactsRequest) CreationAfter(creationAfter time.Time) ApiGetContactsRequest {
	r.creationAfter = &creationAfter
	return r
}

func (r ApiGetContactsRequest) CreationBefore(creationBefore time.Time) ApiGetContactsRequest {
	r.creationBefore = &creationBefore
	return r
}

func (r ApiGetContactsRequest) Account(account []float32) ApiGetContactsRequest {
	r.account = &account
	return r
}

func (r ApiGetContactsRequest) Tag(tag []float32) ApiGetContactsRequest {
	r.tag = &tag
	return r
}

func (r ApiGetContactsRequest) TagName(tagName []string) ApiGetContactsRequest {
	r.tagName = &tagName
	return r
}

func (r ApiGetContactsRequest) PositionRole(positionRole []string) ApiGetContactsRequest {
	r.positionRole = &positionRole
	return r
}

func (r ApiGetContactsRequest) AddressCountry(addressCountry []string) ApiGetContactsRequest {
	r.addressCountry = &addressCountry
	return r
}

func (r ApiGetContactsRequest) AddressStateRegion(addressStateRegion []string) ApiGetContactsRequest {
	r.addressStateRegion = &addressStateRegion
	return r
}

func (r ApiGetContactsRequest) AddressCity(addressCity []string) ApiGetContactsRequest {
	r.addressCity = &addressCity
	return r
}

func (r ApiGetContactsRequest) IncludeArchived(includeArchived bool) ApiGetContactsRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiGetContactsRequest) Search(search string) ApiGetContactsRequest {
	r.search = &search
	return r
}

func (r ApiGetContactsRequest) Type_(type_ string) ApiGetContactsRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetContactsRequest) Limit(limit float32) ApiGetContactsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetContactsRequest) Offset(offset float32) ApiGetContactsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetContactsRequest) Custom(custom string) ApiGetContactsRequest {
	r.custom = &custom
	return r
}

// Can be just &#39;key&#39; e.g. &#39;name&#39; or &#39;key sortOrder&#39; e.g. &#39;name desc&#39;. Defaults to asc.
func (r ApiGetContactsRequest) OrderBy(orderBy []string) ApiGetContactsRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetContactsRequest) Q(q string) ApiGetContactsRequest {
	r.q = &q
	return r
}

func (r ApiGetContactsRequest) Execute() ([]GetContacts200ResponseInner, *http.Response, error) {
	return r.ApiService.GetContactsExecute(r)
}

/*
GetContacts List contacts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetContactsRequest
*/
func (a *ContactsAPIService) GetContacts(ctx context.Context) ApiGetContactsRequest {
	return ApiGetContactsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetContacts200ResponseInner
func (a *ContactsAPIService) GetContactsExecute(r ApiGetContactsRequest) ([]GetContacts200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetContacts200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContactsAPIService.GetContacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contacts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	}
	if r.phoneNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phone_number", r.phoneNumber, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.modificationAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modification_after", r.modificationAfter, "")
	}
	if r.modificationBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modification_before", r.modificationBefore, "")
	}
	if r.creationAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creation_after", r.creationAfter, "")
	}
	if r.creationBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creation_before", r.creationBefore, "")
	}
	if r.account != nil {
		t := *r.account
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account", t, "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.tagName != nil {
		t := *r.tagName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag.name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag.name", t, "multi")
		}
	}
	if r.positionRole != nil {
		t := *r.positionRole
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "position.role", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "position.role", t, "multi")
		}
	}
	if r.addressCountry != nil {
		t := *r.addressCountry
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "address.country", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "address.country", t, "multi")
		}
	}
	if r.addressStateRegion != nil {
		t := *r.addressStateRegion
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "address.state_region", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "address.state_region", t, "multi")
		}
	}
	if r.addressCity != nil {
		t := *r.addressCity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "address.city", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "address.city", t, "multi")
		}
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue float32 = 20.0
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue float32 = 0.0
		r.offset = &defaultValue
	}
	if r.custom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "custom", r.custom, "")
	}
	if r.orderBy != nil {
		t := *r.orderBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostContactsRequest struct {
	ctx context.Context
	ApiService *ContactsAPIService
	force *bool
	body *[]PostContactsRequestInner
}

// When force is false, the contact will not be created if a contact with the same email address used to exist.
func (r ApiPostContactsRequest) Force(force bool) ApiPostContactsRequest {
	r.force = &force
	return r
}

func (r ApiPostContactsRequest) Body(body []PostContactsRequestInner) ApiPostContactsRequest {
	r.body = &body
	return r
}

func (r ApiPostContactsRequest) Execute() ([]PostContacts200ResponseInner, *http.Response, error) {
	return r.ApiService.PostContactsExecute(r)
}

/*
PostContacts Create a contact

When payload is an array you will get an array back, if just an object or an array with 1 item you get an object back

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostContactsRequest
*/
func (a *ContactsAPIService) PostContacts(ctx context.Context) ApiPostContactsRequest {
	return ApiPostContactsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PostContacts200ResponseInner
func (a *ContactsAPIService) PostContactsExecute(r ApiPostContactsRequest) ([]PostContacts200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PostContacts200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContactsAPIService.PostContacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contacts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	} else {
		var defaultValue bool = true
		r.force = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
