# coding: utf-8

"""
    Salesflare API

    # Introduction  ## Getting Started  The Salesflare API allows you to access and build your own applications or integrations that interact with Salesflare.  The Salesflare API provides a RESTful interface with JSON-formatted responses to access most Salesflare resources.  ## Authentication  The Salesflare API uses bearer token based authentication, which means you need to use the key-value pair \"Authorization : Bearer APIKEY\" in the header to authenticate.  You can make an API key in [\"Settings\" > \"API keys\"](https://app.salesflare.com/#/settings/apikeys).  Click on the large orange \"+\" button on the bottom right of the screen to create an API key.  ![Screenshot API Key Settings](https://lib.salesflare.com/api_docs/screenshot_settings_apikeys.png)  ## Requests  All requests must be sent using HTTPS with TLS 1.2 or higher. Please make sure your developer tools support this version of TLS as older versions or SSL are not supported for security reasons.  For PUT or POST requests (e.g. create, update), the payload must be provided as JSON in the request body.  ## Responses  Responses use HTTP status codes, with the most typical ones being:  | Code                   | Meaning               | |------------------------|-----------------------| | Successful Responses                           | | 200                    | OK                    | | Error Responses                                | | 400                    | Bad Request           | | 401                    | Unauthorized          | | 404                    | Not Found             | | 429                    | Too Many Requests     | | 500                    | Internal Server Error |  ## Testing  We recommend testing our API with Postman.  ### Download specification  Our API is documented following the OpenAPI specification. You can download it [here](https://api.salesflare.com/openapi.json)  ### Import in Postman  To import the collection, open Postman and click Import, then select \"Import From Link\"  Copy & Paste the following link and press the \"Import\" button:  > https://api.salesflare.com/openapi.json  ![Screenshot Postman Import](https://lib.salesflare.com/api_docs/screenshot_postman_import.png)  ## Support  For API questions and support, please email support@salesflare.com or click the chat bubble below.

    The version of the OpenAPI document: 1.0.0
    Contact: support@salesflare.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from salesflare.models.get_contacts200_response_inner import GetContacts200ResponseInner
from salesflare.models.post_contacts200_response_inner import PostContacts200ResponseInner
from salesflare.models.post_contacts_request_inner import PostContactsRequestInner

from salesflare.api_client import ApiClient, RequestSerialized
from salesflare.api_response import ApiResponse
from salesflare.rest import RESTResponseType


class ContactsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_contacts(
        self,
        id: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        name: Optional[StrictStr] = None,
        email: Optional[StrictStr] = None,
        phone_number: Optional[StrictStr] = None,
        domain: Optional[StrictStr] = None,
        modification_after: Optional[datetime] = None,
        modification_before: Optional[datetime] = None,
        creation_after: Optional[datetime] = None,
        creation_before: Optional[datetime] = None,
        account: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        tag: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        tag_name: Optional[List[StrictStr]] = None,
        position_role: Optional[List[StrictStr]] = None,
        address_country: Optional[List[StrictStr]] = None,
        address_state_region: Optional[List[StrictStr]] = None,
        address_city: Optional[List[StrictStr]] = None,
        include_archived: Optional[StrictBool] = None,
        search: Optional[StrictStr] = None,
        type: Optional[StrictStr] = None,
        limit: Optional[Union[Annotated[float, Field(strict=True, ge=1)], Annotated[int, Field(strict=True, ge=1)]]] = None,
        offset: Optional[Union[StrictFloat, StrictInt]] = None,
        custom: Optional[StrictStr] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="Can be just 'key' e.g. 'name' or 'key sortOrder' e.g. 'name desc'. Defaults to asc.")] = None,
        q: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[GetContacts200ResponseInner]:
        """List contacts


        :param id:
        :type id: List[float]
        :param name:
        :type name: str
        :param email:
        :type email: str
        :param phone_number:
        :type phone_number: str
        :param domain:
        :type domain: str
        :param modification_after:
        :type modification_after: datetime
        :param modification_before:
        :type modification_before: datetime
        :param creation_after:
        :type creation_after: datetime
        :param creation_before:
        :type creation_before: datetime
        :param account:
        :type account: List[float]
        :param tag:
        :type tag: List[float]
        :param tag_name:
        :type tag_name: List[str]
        :param position_role:
        :type position_role: List[str]
        :param address_country:
        :type address_country: List[str]
        :param address_state_region:
        :type address_state_region: List[str]
        :param address_city:
        :type address_city: List[str]
        :param include_archived:
        :type include_archived: bool
        :param search:
        :type search: str
        :param type:
        :type type: str
        :param limit:
        :type limit: float
        :param offset:
        :type offset: float
        :param custom:
        :type custom: str
        :param order_by: Can be just 'key' e.g. 'name' or 'key sortOrder' e.g. 'name desc'. Defaults to asc.
        :type order_by: List[str]
        :param q:
        :type q: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_contacts_serialize(
            id=id,
            name=name,
            email=email,
            phone_number=phone_number,
            domain=domain,
            modification_after=modification_after,
            modification_before=modification_before,
            creation_after=creation_after,
            creation_before=creation_before,
            account=account,
            tag=tag,
            tag_name=tag_name,
            position_role=position_role,
            address_country=address_country,
            address_state_region=address_state_region,
            address_city=address_city,
            include_archived=include_archived,
            search=search,
            type=type,
            limit=limit,
            offset=offset,
            custom=custom,
            order_by=order_by,
            q=q,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetContacts200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_contacts_with_http_info(
        self,
        id: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        name: Optional[StrictStr] = None,
        email: Optional[StrictStr] = None,
        phone_number: Optional[StrictStr] = None,
        domain: Optional[StrictStr] = None,
        modification_after: Optional[datetime] = None,
        modification_before: Optional[datetime] = None,
        creation_after: Optional[datetime] = None,
        creation_before: Optional[datetime] = None,
        account: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        tag: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        tag_name: Optional[List[StrictStr]] = None,
        position_role: Optional[List[StrictStr]] = None,
        address_country: Optional[List[StrictStr]] = None,
        address_state_region: Optional[List[StrictStr]] = None,
        address_city: Optional[List[StrictStr]] = None,
        include_archived: Optional[StrictBool] = None,
        search: Optional[StrictStr] = None,
        type: Optional[StrictStr] = None,
        limit: Optional[Union[Annotated[float, Field(strict=True, ge=1)], Annotated[int, Field(strict=True, ge=1)]]] = None,
        offset: Optional[Union[StrictFloat, StrictInt]] = None,
        custom: Optional[StrictStr] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="Can be just 'key' e.g. 'name' or 'key sortOrder' e.g. 'name desc'. Defaults to asc.")] = None,
        q: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[GetContacts200ResponseInner]]:
        """List contacts


        :param id:
        :type id: List[float]
        :param name:
        :type name: str
        :param email:
        :type email: str
        :param phone_number:
        :type phone_number: str
        :param domain:
        :type domain: str
        :param modification_after:
        :type modification_after: datetime
        :param modification_before:
        :type modification_before: datetime
        :param creation_after:
        :type creation_after: datetime
        :param creation_before:
        :type creation_before: datetime
        :param account:
        :type account: List[float]
        :param tag:
        :type tag: List[float]
        :param tag_name:
        :type tag_name: List[str]
        :param position_role:
        :type position_role: List[str]
        :param address_country:
        :type address_country: List[str]
        :param address_state_region:
        :type address_state_region: List[str]
        :param address_city:
        :type address_city: List[str]
        :param include_archived:
        :type include_archived: bool
        :param search:
        :type search: str
        :param type:
        :type type: str
        :param limit:
        :type limit: float
        :param offset:
        :type offset: float
        :param custom:
        :type custom: str
        :param order_by: Can be just 'key' e.g. 'name' or 'key sortOrder' e.g. 'name desc'. Defaults to asc.
        :type order_by: List[str]
        :param q:
        :type q: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_contacts_serialize(
            id=id,
            name=name,
            email=email,
            phone_number=phone_number,
            domain=domain,
            modification_after=modification_after,
            modification_before=modification_before,
            creation_after=creation_after,
            creation_before=creation_before,
            account=account,
            tag=tag,
            tag_name=tag_name,
            position_role=position_role,
            address_country=address_country,
            address_state_region=address_state_region,
            address_city=address_city,
            include_archived=include_archived,
            search=search,
            type=type,
            limit=limit,
            offset=offset,
            custom=custom,
            order_by=order_by,
            q=q,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetContacts200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_contacts_without_preload_content(
        self,
        id: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        name: Optional[StrictStr] = None,
        email: Optional[StrictStr] = None,
        phone_number: Optional[StrictStr] = None,
        domain: Optional[StrictStr] = None,
        modification_after: Optional[datetime] = None,
        modification_before: Optional[datetime] = None,
        creation_after: Optional[datetime] = None,
        creation_before: Optional[datetime] = None,
        account: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        tag: Optional[List[Union[StrictFloat, StrictInt]]] = None,
        tag_name: Optional[List[StrictStr]] = None,
        position_role: Optional[List[StrictStr]] = None,
        address_country: Optional[List[StrictStr]] = None,
        address_state_region: Optional[List[StrictStr]] = None,
        address_city: Optional[List[StrictStr]] = None,
        include_archived: Optional[StrictBool] = None,
        search: Optional[StrictStr] = None,
        type: Optional[StrictStr] = None,
        limit: Optional[Union[Annotated[float, Field(strict=True, ge=1)], Annotated[int, Field(strict=True, ge=1)]]] = None,
        offset: Optional[Union[StrictFloat, StrictInt]] = None,
        custom: Optional[StrictStr] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="Can be just 'key' e.g. 'name' or 'key sortOrder' e.g. 'name desc'. Defaults to asc.")] = None,
        q: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List contacts


        :param id:
        :type id: List[float]
        :param name:
        :type name: str
        :param email:
        :type email: str
        :param phone_number:
        :type phone_number: str
        :param domain:
        :type domain: str
        :param modification_after:
        :type modification_after: datetime
        :param modification_before:
        :type modification_before: datetime
        :param creation_after:
        :type creation_after: datetime
        :param creation_before:
        :type creation_before: datetime
        :param account:
        :type account: List[float]
        :param tag:
        :type tag: List[float]
        :param tag_name:
        :type tag_name: List[str]
        :param position_role:
        :type position_role: List[str]
        :param address_country:
        :type address_country: List[str]
        :param address_state_region:
        :type address_state_region: List[str]
        :param address_city:
        :type address_city: List[str]
        :param include_archived:
        :type include_archived: bool
        :param search:
        :type search: str
        :param type:
        :type type: str
        :param limit:
        :type limit: float
        :param offset:
        :type offset: float
        :param custom:
        :type custom: str
        :param order_by: Can be just 'key' e.g. 'name' or 'key sortOrder' e.g. 'name desc'. Defaults to asc.
        :type order_by: List[str]
        :param q:
        :type q: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_contacts_serialize(
            id=id,
            name=name,
            email=email,
            phone_number=phone_number,
            domain=domain,
            modification_after=modification_after,
            modification_before=modification_before,
            creation_after=creation_after,
            creation_before=creation_before,
            account=account,
            tag=tag,
            tag_name=tag_name,
            position_role=position_role,
            address_country=address_country,
            address_state_region=address_state_region,
            address_city=address_city,
            include_archived=include_archived,
            search=search,
            type=type,
            limit=limit,
            offset=offset,
            custom=custom,
            order_by=order_by,
            q=q,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[GetContacts200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_contacts_serialize(
        self,
        id,
        name,
        email,
        phone_number,
        domain,
        modification_after,
        modification_before,
        creation_after,
        creation_before,
        account,
        tag,
        tag_name,
        position_role,
        address_country,
        address_state_region,
        address_city,
        include_archived,
        search,
        type,
        limit,
        offset,
        custom,
        order_by,
        q,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'id': 'multi',
            'account': 'multi',
            'tag': 'multi',
            'tag.name': 'multi',
            'position.role': 'multi',
            'address.country': 'multi',
            'address.state_region': 'multi',
            'address.city': 'multi',
            'order_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if email is not None:
            
            _query_params.append(('email', email))
            
        if phone_number is not None:
            
            _query_params.append(('phone_number', phone_number))
            
        if domain is not None:
            
            _query_params.append(('domain', domain))
            
        if modification_after is not None:
            if isinstance(modification_after, datetime):
                _query_params.append(
                    (
                        'modification_after',
                        modification_after.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('modification_after', modification_after))
            
        if modification_before is not None:
            if isinstance(modification_before, datetime):
                _query_params.append(
                    (
                        'modification_before',
                        modification_before.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('modification_before', modification_before))
            
        if creation_after is not None:
            if isinstance(creation_after, datetime):
                _query_params.append(
                    (
                        'creation_after',
                        creation_after.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('creation_after', creation_after))
            
        if creation_before is not None:
            if isinstance(creation_before, datetime):
                _query_params.append(
                    (
                        'creation_before',
                        creation_before.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('creation_before', creation_before))
            
        if account is not None:
            
            _query_params.append(('account', account))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if tag_name is not None:
            
            _query_params.append(('tag.name', tag_name))
            
        if position_role is not None:
            
            _query_params.append(('position.role', position_role))
            
        if address_country is not None:
            
            _query_params.append(('address.country', address_country))
            
        if address_state_region is not None:
            
            _query_params.append(('address.state_region', address_state_region))
            
        if address_city is not None:
            
            _query_params.append(('address.city', address_city))
            
        if include_archived is not None:
            
            _query_params.append(('includeArchived', include_archived))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if custom is not None:
            
            _query_params.append(('custom', custom))
            
        if order_by is not None:
            
            _query_params.append(('order_by', order_by))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/contacts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_contacts(
        self,
        force: Annotated[Optional[StrictBool], Field(description="When force is false, the contact will not be created if a contact with the same email address used to exist.")] = None,
        body: Optional[List[PostContactsRequestInner]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[PostContacts200ResponseInner]:
        """Create a contact

        When payload is an array you will get an array back, if just an object or an array with 1 item you get an object back

        :param force: When force is false, the contact will not be created if a contact with the same email address used to exist.
        :type force: bool
        :param body:
        :type body: List[PostContactsRequestInner]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_contacts_serialize(
            force=force,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PostContacts200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_contacts_with_http_info(
        self,
        force: Annotated[Optional[StrictBool], Field(description="When force is false, the contact will not be created if a contact with the same email address used to exist.")] = None,
        body: Optional[List[PostContactsRequestInner]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[PostContacts200ResponseInner]]:
        """Create a contact

        When payload is an array you will get an array back, if just an object or an array with 1 item you get an object back

        :param force: When force is false, the contact will not be created if a contact with the same email address used to exist.
        :type force: bool
        :param body:
        :type body: List[PostContactsRequestInner]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_contacts_serialize(
            force=force,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PostContacts200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_contacts_without_preload_content(
        self,
        force: Annotated[Optional[StrictBool], Field(description="When force is false, the contact will not be created if a contact with the same email address used to exist.")] = None,
        body: Optional[List[PostContactsRequestInner]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a contact

        When payload is an array you will get an array back, if just an object or an array with 1 item you get an object back

        :param force: When force is false, the contact will not be created if a contact with the same email address used to exist.
        :type force: bool
        :param body:
        :type body: List[PostContactsRequestInner]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_contacts_serialize(
            force=force,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PostContacts200ResponseInner]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_contacts_serialize(
        self,
        force,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if force is not None:
            
            _query_params.append(('force', force))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/contacts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


